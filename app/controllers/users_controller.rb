class UsersController < ApplicationController
  before_filter :authenticate_user!, :except => [:profile, :netwurq, :search, :interest_list]
  load_and_authorize_resource
  skip_load_and_authorize_resource :only => [:profile, :netwurq, :search, :interest_list]
  respond_to :html, :json
  
  # dashboard page
  #   -landing page when a user signs in
  #
  def dashboard

  end
  
  # settings page
  #   -page for a user to update their profile and settings
  #
  # * *Args*    :
  #   - +sort+ -> sort testimonials (1 for ASC)
  #   - +page+ -> used with pagination
  #   - +error+ -> facebook connect error (if applicable)
  # * *Returns* :
  #   - User attributes as json object
  #
  def settings
    @user = current_user
    
    respond_to do |format|
      format.json { render :json => @user }
      format.html { render :layout => 'home'}
    end
  end

  # update action
  #   -json action to update a user's settings
  #
  # * *Args*    :
  #   - +user=>**+ -> User's Attributes
  # * *Returns* :
  #   - User's attributes as a json object
  # * *Raises* :
  #   - +Errors+ -> if the user object fails to save
  #
  def update
    @user = User.find(current_user.id)
    if @user.update_attributes(params[:user])
      sign_in(@user, :bypass => true)
      redirect_to dashboard_users_path, :notice => 'Settings updated successfully!'
    else
      render 'settings'
    end
  end

  # change_photo action
  #   -form to upload a new picture as a user's avatar
  #
  # * *Args*    :
  #   - +user=>profile_picture+ -> picture file
  # * *Returns* :
  #   - medium and large urls generated by paperclip
  # * *Raises* :
  #   - +0+ -> if the upload fails
  #
  def change_photo
    user = User.find(current_user.id)
    user.profile_picture = params[:user][:profile_picture]
    if user.save
      render :json => {
        :medium => user.profile_picture.url(:medium),
        :large => user.profile_picture.url(:large)
      }
    else
      render :json => 0
    end
  end
  
  # delete_photo action
   #   -form to upload a remove picture as a user's avatar
   #
   # * *Returns* :
   #   - medium and large urls generated by paperclip (default avatars)
   # * *Raises* :
   #   - +0+ -> if the delete fails
   #
  def delete_photo
    user = User.find(current_user.id)
    user.profile_picture.destroy
    if user.save
      render :json => {
        :medium => user.profile_picture.url(:medium),
        :large => user.profile_picture.url(:large)
      }
    else
      render :json => 0
    end
  end

  # schedule_appointment action
  #   -page where a wurqer schedules a wurqout with a guru
  #
  # * *Args*    :
  #   - +user_id+ -> Guru's ID
  # * *Returns* :
  #   - the schedule page with a @guru assign
  # * *Raises* :
  #   - +redirection+ -> if the guru's ID is your own ID, your timezone is not set, or the guru has no rates set
  #
  def schedule_appointment
    @wurqout_session = WurqoutSession.new
    @guru = User.find(params[:user_id])
    if current_user.id == params[:user_id].to_i
      redirect_to user_profile_path(current_user.id)
    elsif current_user.timezone.blank?
      redirect_to settings_users_path, :alert => 'You must set your timezone to schedule a wurqout.'
    elsif !@guru.guru_rates_set?
      redirect_to user_profile_path(@guru.id), :alert => 'This Guru is not accepting wurqout sessions at this time'
    end
  end
  
  # update_schedule action
  #   -retrieves the gurus available schedule based on duration and month
  #
  # * *Args*    :
  #   - +duration+ -> length of desired wurqout (in minutes)
  #   - +month+ -> month of gurus availability
  #   - +year+ -> year of gurus availability
  # * *Returns* :
  #   - the gurus availability spans in a json array
  #
  def update_schedule
    @user = User.find(params[:user_id])
    @data = @user.get_schedule_availability(params, current_user, false, 0)
    render :json => @data
  end

  # search action
  #   -searches wurqers and gurus when scheduling a wurqout
  #
  # * *Args*    :
  #   - +user=>gender+ -> Desired gender of co-wurqer or guru
  #   - +max_price+ -> Largest amount you are will to pay for a session
  #   - +search_type+ -> Desired user type (guru or wurqer)
  #   - +wurqout_prefernce_beginner+ -> true if looking for a beginner's session
  #   - +wurqout_prefernce_inetermediate+ -> true if looking for a intermediate session
  #   - +wurqout_prefernce_advanced+ -> true if looking for a advanced session
  #   - +wurqout_prefernce_hardcore+ -> true if looking for a hardcore session
  #   - +user=>user_interests_attributes+ -> hash of desired interests (eg. Yoga)
  # * *Returns* :
  #   - An array of user's that match the given criteria
  #
  def search
    @user = User.new
    
    if params[:query]
      if !params[:query].blank?
        @results = query_search(params[:query], params[:role], params)
      else
        @results = User.paginate(:page => params[:page], :per_page => 20).joins(:roles).where("`roles`.`role`=?", params[:role])
      end
      return
    end
    
    #when search params are passed in
    if params[:user]
      gender = params[:user][:gender]
      max_price = params[:max_price]
      user_type = params[:search_type]
      wurqout_preference_beginner = params[:wurqout_preference_beginner]
      wurqout_preference_intermediate = params[:wurqout_preference_intermediate]
      wurqout_preference_advanced = params[:wurqout_preference_advanced]
      wurqout_preference_hardcore = params[:wurqout_preference_hardcore]
      interests = params[:user][:user_interests_attributes]
       
      if gender == 'either'
        gender = '*'
      end
      
      if ELASTICSEARCH['search_engine_enabled']
         @results = exec_search(gender, 
                    user_type, 
                    max_price, 
                    wurqout_preference_beginner, 
                    wurqout_preference_intermediate, 
                    wurqout_preference_advanced, 
                    wurqout_preference_hardcore, 
                    interests, params)
      end
      
      @search_type = user_type
      #no params passed in do a default search  
    else
       #user signed in
      if user_signed_in?
        if !params[:role].nil?
          if params[:role] == 'guru'
            @search_type = 'guru'
          end
          if params[:role] == 'wurqer'
            @search_type = 'wurqer'
          end
        else
          @search_type = 'guru'
        end
      
        params[:user] = {}
        #params[:wurqout_preference_beginner] = current_user.wurqout_preference_beginner
        #params[:wurqout_preference_intermediate] = current_user.wurqout_preference_intermediate
        #params[:wurqout_preference_advanced] = current_user.wurqout_preference_advanced
        #params[:wurqout_preference_hardcore] = current_user.wurqout_preference_hardcore
      
        params[:user][:user_interests_attributes] = {}
        current_user.user_interests.each_with_index do |interest, index|
          params[:user][:user_interests_attributes][index] = {}
          params[:user][:user_interests_attributes][index][:interest] = interest.interest
        end
      
        if ELASTICSEARCH['search_engine_enabled']
           @results = exec_search("*", 
                      @search_type, 
                      max_price, 
                      current_user.wurqout_preference_beginner, 
                      current_user.wurqout_preference_intermediate, 
                      current_user.wurqout_preference_advanced, 
                      current_user.wurqout_preference_hardcore, 
                      params[:user][:user_interests_attributes], params)
        end
        params[:user] = {}
        params[:user][:gender] = 'either'
        
      #no params passed user not signed in - random results  
      else
        
         if !params[:role].nil?
            if params[:role] == 'guru'
              @search_type = 'guru'
            end
            if params[:role] == 'wurqer'
              @search_type = 'wurqer'
            end
          else
            @search_type = 'guru'
          end
        
        @results = User.paginate(:page => params[:page], :per_page => 20).joins(:roles).where("`roles`.`role`=?", @search_type).random(20)
      end
    end
      
  end

  # profile page
  #   -page displaying a given user's profile
  #
  # * *Args*    :
  #   - +user_id+ -> Given user's ID
  # * *Returns* :
  #   - profile page with @user assign
  #
  def profile
    @user = User.find(params[:user_id])
  end

  # availability page
  #   -page where a guru sets their availability for wurqout sessions
  #
  # * *Returns* :
  #   - the availability page
  # * *Raises* :
  #   - +redirection+ -> if the user is a wurqer, or the guru has no timezone set
  #
  def availability
    if current_user.role?('wurqer')
      redirect_to settings_users_path, :notice => 'Availability scheduling is for Gurus only.'
    elsif current_user.timezone.blank?
      redirect_to settings_users_path, :notice => 'You must set your Timezone to update your schedule.'
    end
  end

  # get_availability action
  #   -retrieve's a guru's current availability to fill in the calendar
  #
  # * *Returns* :
  #   - the gurus availability from now to next month as a json array
  #
  def get_availability
    @user = current_user
    @data = @user.get_availability()
    render :json => {:events => @data, :freebusys => [{:start => DateTime.now - 10.years, :end => DateTime.now, :free => false},
                                                      {:start => DateTime.now + 1.month, :end => DateTime.now+10.years, :free => false}]}
  end

  # set_availability action
  #   -action to set a guru's availability
  #
  # * *Args*    :
  #   - +start+ -> Start date/time for availability
  #   - +end+ -> End date/time for availability
  #   - +recurring+ -> true if the availability recurs each week
  # * *Returns* :
  #   - the new event's ID for the calendar
  #
  def set_availability
    @user = current_user
    @start = DateTime.parse(params[:start])
    @end = DateTime.parse(params[:end])
    if params[:recurring] == 'true'
      @start = @start.in_time_zone('UTC')
      @end = @end.in_time_zone('UTC')
      # destroy any current recurring availabilities at this time
      @user.guru_recurring_availabilities.select{|avail| avail.weekday == @start.wday and ((Time.parse(avail.start_time.strftime('%T')) > Time.parse(@start.strftime('%T')) and Time.parse(avail.start_time.strftime('%T')) < Time.parse(@end.strftime('%T'))) or (Time.parse(avail.end_time.strftime('%T')) > Time.parse(@start.strftime('%T')) and Time.parse(avail.end_time.strftime('%T')) < Time.parse(@end.strftime('%T')))) }.each do |avail|
        avail.destroy
      end
      @av = GuruRecurringAvailability.create(:start_time => @start, :end_time => @end, :weekday => @start.in_time_zone(current_user.timezone).wday, :user_id => @user.id)
      @event_id = 'recur_'+@av.id.to_s
    else
      # destroy any current scheduled availabilities at this date/time
      @user.guru_scheduled_availabilities.where(["(start_date > ? and start_date < ?) or (end_date > ? and end_date < ?)", @start, @end, @start, @end]).each do |avail|
        avail.destroy
      end
      @av = GuruScheduledAvailability.create(:start_date => @start, :end_date => @end, :user_id => @user.id)
      @event_id = @av.id
    end
    render :json => {:event_id => @event_id}
  end

  # update_availability action
  #   -action to update an existing guru availability
  #
  # * *Args*    :
  #   - +event_id+ -> ID t=of the current event (availability)
  #   - +slot=>start+ -> Start date/time for availability
  #   - +slot=>end+ -> End date/time for availability
  #   - +recurring+ -> true if the availability recurs each week
  # * *Returns* :
  #   - the updated event's ID for the calendar
  #
  def update_availability
    @user = current_user
    @start = DateTime.parse(params[:slot][:start])
    @end = DateTime.parse(params[:slot][:end])
    if params[:recurring] == 'true'
      if params[:event_id].index('recur')
        #updates a recurring event
        @avail = GuruRecurringAvailability.find(params[:event_id].split('_')[1])
        @avail.update_attributes({:start_time => @start, :end_time => @end, :weekday => @start.wday})
        @event_id = params[:event_id]
      else
        #updates a recurring event to a scheduled event
        @avail = GuruScheduledAvailability.find(params[:event_id])
        @avail.destroy
        @user.guru_recurring_availabilities.select{|avail| avail.weekday == @start.wday and ((Time.parse(avail.start_time.in_time_zone(current_user.timezone).strftime('%T')) > Time.parse(@start.strftime('%T')) and Time.parse(avail.start_time.in_time_zone(current_user.timezone).strftime('%T')) < Time.parse(@end.strftime('%T'))) or (Time.parse(avail.end_time.in_time_zone(current_user.timezone).strftime('%T')) > Time.parse(@start.strftime('%T')) and Time.parse(avail.end_time.in_time_zone(current_user.timezone).strftime('%T')) < Time.parse(@end.strftime('%T')))) }.each do |avail|
          avail.destroy
        end
        @av = GuruRecurringAvailability.create(:start_time => @start, :end_time => @end, :weekday => @start.wday, :user_id => @user.id)
        @event_id = 'recur_'+@av.id.to_s
      end
    else
      if params[:event_id].index('recur')
        # updates a scheduled event to a recurring event
        @avail = GuruRecurringAvailability.find(params[:event_id].split('_')[1])
        @avail.destroy
        @av = GuruScheduledAvailability.create(:start_date => @start, :end_date => @end, :user_id => @user.id)
        @event_id = @av.id
      else
        # updates a scheduled event
        @avail = GuruScheduledAvailability.find(params[:event_id])
        @user.guru_scheduled_availabilities.where(["id != #{@avail.id} and ((start_date > ? and start_date < ?) or (end_date > ? and end_date < ?))", @start, @end, @start, @end]).each do |avail|
          avail.destroy
        end
        @avail.update_attributes({:start_date => @start, :end_date => @end})
        @event_id = @avail.id
      end
    end
    render :json => {:event_id => @event_id}
  end

  # remove_availability action
  #   -action to delete a guru's availability
  #
  # * *Args*    :
  #   - +av_id+ -> ID of the availability
  # * *Returns* :
  #   - 1 if the deletion was successful
  #
  def remove_availability
    if params[:av_id].index('recur')
      @avail = GuruRecurringAvailability.find(params[:av_id].split('_')[1])
    else
      @avail = GuruScheduledAvailability.find(params[:av_id])
    end
    @avail.destroy
    render :json => 1
  end

  # schedule page
  #   -page to view your current scheduled wurqouts
  #
  #
  def schedule
    now = DateTime.now.in_time_zone('UTC').to_s
    @upcoming_sessions = WurqoutSession.find(:all, :conditions => "(wurqer_id = #{current_user.id} or guru_id = #{current_user.id}) and start_date > '#{now}' and status not like '%cancelled%'").to_a
    @upcoming_sessions += CowurqSession.find(:all, :conditions => "(user_id = #{current_user.id} or cowurqer_id = #{current_user.id}) and start_date > '#{now}' and status != 'cancelled'").to_a
    @ws_history = WurqoutSession.paginate(:per_page => 5, :page => params[:guru_sessions], :conditions => "(wurqer_id = #{current_user.id} or guru_id = #{current_user.id}) and start_date < '#{now}' and status not like '%cancelled%'", :order => 'start_date desc')
    @cs_history = CowurqSession.paginate(:per_page => 5, :page => params[:cowurq_sessions], :conditions => "(user_id = #{current_user.id} or cowurqer_id = #{current_user.id}) and start_date < '#{now}' and status != 'cancelled'", :order => 'start_date desc')
  end
  
  # get_my_schedule action
  #   -to get a user's schedule
  #
  # * *Args*    :
  #   - +month+ -> month of current schedule
  #   - +year+ -> year of current schedule
  # * *Returns* :
  #   - data array of current schedule
  #
  def get_my_schedule
    @data = current_user.get_my_schedule(params)
    render :json => @data
  end

  # sync_to_gcal action
  #   -to sync a user's wurqout schedule to their google calendar
  #
  # * *Args*    :
  #   - +user_id+ -> User's ID
  #   - +gcal_pw+ -> Google password
  # * *Returns* :
  #   - json response of 1 on success
  #
  def sync_to_gcal
    @user = User.find(params[:user_id])
    @user.sync_to_gcal(params[:gcal_pw])
    render :json => 1
  end

  # exec_search action
  #   -private method to search users if elastic search is enabled
  #
  private
    def exec_search(gender, user_type, max_price, wurqout_preference_beginner, wurqout_preference_intermediate, wurqout_preference_advanced, wurqout_preference_hardcore, interests, params)
      user_id = current_user.id
      wurqout_preference_conditions = []

      if wurqout_preference_beginner
        wurqout_preference_conditions << {:term => {:wurqout_preference_beginner => ['true']}}
      end
      
      if wurqout_preference_intermediate
        wurqout_preference_conditions << {:term => {:wurqout_preference_intermediate => ['true']}}
      end

      if wurqout_preference_advanced    
        wurqout_preference_conditions << {:term => {:wurqout_preference_advanced => ['true']}}
      end

      if wurqout_preference_hardcore
        wurqout_preference_conditions << {:term => {:wurqout_preference_hardcore => ['true']}}
      end
      
       @results = User.search(load: true, :page => (params[:page] || 1), :per_page => 10) do
         query do
           boolean do
             if !gender.nil? or gender != '*'
               must   { string "gender:#{gender}" }
             end
             must   { string "user_type:#{user_type}" }
             must_not {string "id:#{user_id}"}
             if max_price != '' and !max_price.nil?
               must   { string "guru_pricing_tier1:[0 TO #{max_price}]" }
             end
             
             if !interests.nil?
               interests.each do | obj |
                 current_interest = obj[1][:interest]
                 if interests.size > 2
                   should {string "interests:#{current_interest}"}
                 else
                   must {string "interests:#{current_interest}"}
                 end
               end
             end
           end
         end
         if wurqout_preference_conditions.size > 0
           filter :or, wurqout_preference_conditions
         end
         if user_type == 'guru'
           sort { by :rating, 'desc' }
         end
       end
      return @results
    end
    
    def query_search(query, user_type, params)
       @results = User.search(load: true, :page => (params[:page] || 1), :per_page => 10) do
         query do
           boolean do
             should {string "interests:#{query}"}
             should {string "member_name:#{query}"}
             should {string "interests:#{query}"}
           end
        end
        filter :terms, :user_type => [user_type]
      end
      return @results
    end
  
end
